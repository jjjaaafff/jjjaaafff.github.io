<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Linear Methods for Regression | Aofan Jiang</title> <meta name="author" content="Aofan Jiang"> <meta name="description" content="Book Notes on Pattern Recognition and Machine Learning (PRML)"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jjjaaafff.github.io/blog/2021/ml2/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Linear Methods for Regression",
      "description": "Book Notes on Pattern Recognition and Machine Learning (PRML)",
      "published": "July 22, 2021",
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span>Aofan Jiang (蒋傲凡)</span></a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Linear Methods for Regression</h1> <p>Book Notes on Pattern Recognition and Machine Learning (PRML)</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#linear-regression-model">Linear Regression Model</a></div> <div><a href="#least-squares">Least Squares</a></div> <div><a href="#sequential-learning">Sequential Learning</a></div> <div><a href="#the-bias-variance-decomposition">The Bias-Variance Decomposition</a></div> <div><a href="#bayesian-linear-regression">Bayesian Linear Regression</a></div> </nav> </d-contents> <h2 id="linear-regression-model">Linear Regression Model</h2> <p>我们假设输入为 n 个数据，每个数据为 p 维；输出为 n 个一维数据。\(X_i\), \(\hat{y}\), \(\hat{\beta}\) 均为列向量，\(X=[X_1^T,X_2^T,...,X_n^T]^T\) 那么此时线性模型有如下形式</p> \[f(X) = \beta_0 + \sum_{i=1}^pX_i\beta_i\] <p>到后来我们可以发现，这里的截距 \(\beta_0\) 是用于补偿训练输入的标签均值和训练数据的加权平均之间的差异。为了方便表示，我们将 \(\beta_0\) 整合进模型，即此时 \(X=[1, X_1^T,X_2^T,...,X_n^T]^T\) 为 n*(p+1) 的矩阵，预测输出 \(\hat{y}\) 为 n*1 的列向量，线性模型 \(\hat{\beta}\) 为 (p+1)*1 的列向量，则此时我们有</p> \[Y^* = X\beta + \epsilon\] <p>这里 \(y^*\) 表示ground-truth；\(\epsilon\) 为误差项，是 n*1 的列向量，假设服从正态分布；\(Y_{pred} = X\beta\)</p> <p>值得注意的是，当我们需要同时输出多个值时（即 \(\boldsymbol{y_i}\) 为 K 维 vector），此时我们完全可以将其看成 K 个独立的回归问题。这是因为在高斯噪声分布下，我们的模型参数 \(\beta\) 只定义了噪声分布的均值，而它与方差独立（在极大似然的解下）。</p> <h2 id="least-squares">Least Squares</h2> <p>在回归任务中，我们希望误差越小越好，也就是说，我们希望 \(min_{\beta}\ \epsilon\) 。在这其中，最常用的一种估计方法是最小二乘，用来最小化残差和，这里我们首先给出它的形式<br> \(RSS(\beta) = \sum_{i=1}^n (y_i^*-x_i^T\beta)^2\)<br> 我们通过这个损失函数来优化我们的线性模型 \(\beta\) 。此时我们的目标转化为</p> \[\hat{\beta} = argmin_{\beta} ||Y-X\beta||^2\] <p>因为这是一个二次函数，我们可以直接通过梯度得到其解析解，即</p> \[\frac{\partial RSS}{\partial \beta} = -2X^T(Y-X\beta) = 0 \Rightarrow \beta = (X^TX)^{-1}X^TY\] <p>此时，我们可以得到输出预测值为</p> \[\hat{Y} = X\beta = X(X^TX)^{-1}X^TY\] <p>预测值 \(\hat{Y}\) 可以看成是真实值 Y 在 X 的列向量所构成的子空间上的投影，而残差 \(\epsilon\) 垂直与这个子空间。矩阵 \(H = X(X^TX)^{-1}X^T\) 用于计算正交投影。有时 X 中的数据不是线性独立的，则此时我们的模型 \(\beta\) 不是唯一表示的，我们可以通过重编码或去掉冗余数据来解决这一问题。在图片和信号处理中经常出现这一问题，我们通常用滤波降维，或者正则化控制拟合。</p> <p>以上是我们对最小二乘的介绍及求解，接下来我们分析最小二乘为什么是对的。或者说，为什么最小二乘法这么流行。</p> <p>最小二乘法实际上与极大似然估计是相联系的。我们假设误差服从高斯分布，即 \(\epsilon \sim N(0,1)\) ，结合之前的关系，我们有</p> \[y_i^*-x_i^T\beta=\epsilon_i \Rightarrow P(y_i^*\vert x_i)=p(\epsilon_i)=\frac{1}{\sqrt{2\pi}}exp(-(y_i^*-x_i^T\beta)^2/2)\] <p>此时，我们化简极大似然的公式</p> \[logP(y_i^*\vert x_i)=-\frac{1}{2}(y_i^*-x_i^T\beta)^2 + constant\] <p>所以我们可以看出，当我们最小化最小二乘loss时，相当于我们在最大化极大似然。即当误差服从高斯分布时，最小二乘与最大似然等价。</p> <p>那为什么极大似然又是正确的呢？<br> 这里我们用 \(P_{data}(x,y)\) 表示世界上无穷的真实分布，我们的训练集 \((x_i,y_i)\) 是从 \(P_{data}(x,y)\) 采样得到。首先介绍大数定律，当采样数足够大时，我们有</p> \[E_{P_{data}}[h(x)] \approx \sum_x P_{data}(x)h(x) = \frac{1}{n}\sum_{i=1}^nh(x_i)\] <p>根据极大似然的定义，结合大数定律，我们可以写出其数学形式</p> \[max_{\theta} L(\theta) \equiv max_{\theta}\frac{1}{n}\sum_{i=1}^nlogP_{\theta}(y_i\vert x_i) \equiv E_{P_{data}}[logP_{\theta}(y\vert x)]\] <p>此时我们可以在优化目标中加上一项 \(E_{P_{data}}[logP_{data}(y\vert x)]\) ，这一项与 \(\theta\) 模型无关，对模型优化无影响。其中 \(P_{data}(y\vert x)\) 表示ground-truth 的条件概率（上帝角度）。加入该项后，我们对优化目标改写并化简可得到</p> \[max_{\theta} L(\theta) \equiv min_{\theta} \{ -E_{P_{data}}[logP_{\theta}(y\vert x)] + E_{P_{data}}[logP_{data}(y\vert x)] \}\] <p>我们可以看到，这就是模型 \(P_{\theta}(y\vert x)\) 与 ground-truth \(P_{data}(y \vert x)\) 的 KL 距离。</p> <p>对于判别分类模型来说，极大似然估计的本质是最小化模型与真实之间的 KL 距离</p> <h2 id="sequential-learning">Sequential Learning</h2> <p>尽管我们在上面已经得到了最小二乘对应的模型解析解，但当数据集非常大时，这样的计算消耗很大，为此我们需要采用在线算法，逐步地去迭代更新我们的模型。在这里我们考虑 stochastic gradient descent SGD 方法，每次选取 n 个数据，对这 n 个数据的Loss \(L_n\)求和，并更新模型，更新方式如下</p> \[\beta^{(t+1)} = \beta^{(t)} - \eta\nabla L_n\] <p>这里 t 为迭代次数，\(\eta\) 为学习率，模型一开始被设为初值 \(\beta^{(0)}\) ，具体到线性模型中，在采用最小二乘 Loss 时，对应的更新公式为</p> \[\beta^{(t+1)} = \beta^{(t)} + \eta \sum_{i=1}^n(y_i^*-x_i^T\beta^{(t)})x_i\] <p>线性模型下的梯度下降算法又被称为 least-mean-squares or the LMS algorithm 。这里的学习率需要仔细选取来保证算法收敛。</p> <h2 id="regularized-least-squares">Regularized Least Squares</h2> <p>为了抑制过拟合的现象，我们可以在损失函数中添加正则项。这里我们主要介绍两种正则方式，分别是 Ridge Regression 和 Least Absolute Shrinkage and Selection Operator (LASSO)</p> <h3 id="ridge-regression">Ridge Regression</h3> <p>在 Ridge Regression 下，我们改写最小二乘的loss函数为</p> \[L(\beta) = ||Y-X\beta||^2 + \lambda||\beta||^2\] <p>其中 \(\lambda\vert\vert\beta\vert\vert^2\) 为正则项。这种正则方式类似于枪打出头鸟，惩罚明显特征，迫使模型关注更多的其他特征。添加正则项后，损失函数仍然是二次方程，因此可以利用和上面相同的方法直接得到模型的解析解，即</p> \[\beta_{\lambda} = (X^TX+\lambda I_p)^{-1}X^TY\] <h3 id="lasso">Lasso</h3> <p>在 Lasso 下，我们改写最小二乘的loss函数为</p> \[L(\beta) = ||Y-X\beta||^2 + \lambda||\beta||_{l1},\quad where \ ||\beta||_{l1}=\sum_{j=1}^n|\beta_j|\] <p>这种正则方式的意义是让模型不能每个feature都用。当输入数据为高维时没有解析解，当其为一维时，可得</p> \[\beta_{\lambda} = sign(\gamma)max(0,|\gamma|-\lambda/||X||^2), \quad where \ \gamma = (Y,X)/||X||^2\] <p>和 Ridge Regression 相比</p> <ul> <li>Ridge：L2正则化，no dominating features，使权重接近0</li> <li>Lasso：L1正则化，容易使权重取0，直接去掉以产生sparse feature，也用作 feature selection</li> </ul> <p>那么为什么 L1 正则会导致稀疏呢？<br> 这是因为利用 Lagrange 求解时，L1 对权重的限制空间为矩形，而 L2 为圆形。由于 Lasso 对模型 \(\beta\) 的限制是有棱角的，因此解更容易相切在某一维为0的点</p> <h2 id="the-bias-variance-decomposition">The Bias-Variance Decomposition</h2> <p>在这里我们来分析一下 Loss function 中的 bias 与 variance</p> <p>在 squared loss function 下，理论上最好的模型是条件分布的期望。我们用 \(h(x)^{\star}\) 表示理论上最好的模型，可以将其表示为</p> \[h(x)^* = E[y\vert x] = \int yP(y \vert x)dy\] <p>接下来我们写出 squared loss 的期望值，记为 E[L]</p> \[E[L] = \int \{f(x)-h(x)^*\}^2p(x)dx +\int \{h(x)^* - y^*\}^2p(x,y)dxdy\] <p>这里我们实际建模得到的模型是 \(f(x)\) ，首先关注上式中的第二项，它与我们建立的模型无关。它的意义是理论上最好的模型作出的预测误差，这来源于数据自身内部的噪声，我们对此无能为力。理论上第二项也是我们能得到的最小误差。<br> 而第一项则取决于我们实际建模的模型，我们的优化也是为了找到使第一项最小的模型。换句话说，如果我们有无限的数据，无限的计算资源，那么我们就可以建模出理论最优模型 \(h(x)^*\) ，从而使第一项完全消除。</p> <p>接下来我们进一步考虑第一项。在实际中，我们只能通过一个具体的数据集 D 来训练模型。所以在这里我们用 \(f(x;D)\) 代替上式中的 \(f(x)\) ，表示通过数据集 D 训练得到的模型。如果我们对世界上所有的数据集求期望，可改写第一项为</p> \[E_D[\{f(x;D)-h(x)^*\}^2] = \{E_D[f(x;D)]-h(x)^*\}^2+E_D[\{f(x;D)-E_D[f(x;D)]\}^2]\] <p>此时，上式中的第一项即为 bias 的平方，表示在世界上所有数据集的平均预测结果与理论最优模型之间的差距。上式中的第二项即为 variance，表示在某个特定数据集上的表现结果与在所有数据集上表现结果的差距。我们将其代入 squared loss 的期望值，可以得到</p> \[expected\ loss = (bias)^2 + variance + noise\] <p>bias 和 variance 之间存在一种tradeoff的关系。如果我们的模型在所有数据集上都能较好地表现（即bias低），那么当其应用于某一特定的数据集时，其表现就会略差一些（即variance高）。相反，如果我们的模型只专门针对某个特定的数据集，那么可以学习得很好（即variance低），此时作用在其他数据集上，表现就会差一些（即bias高）。所以我们需要找一个最佳的模型去tradeoff bias and variance</p> <p>以上都是理论上的分析，帮助理解 bias 与 variance 之间的矛盾。在实际中，我们只能得到一个观测数据集，无法去分析具体的 bias 与 variance 值。即使有多个数据集，我们也可以将其合并为一个数据集以实现更好的预测结果。</p> <h2 id="bayesian-linear-regression">Bayesian Linear Regression</h2> <p>在上面的内容中，我们主要是从频率学派的观点来看待，即认为参数是固定的、未知的常量，我们只需要按某种方法去达到它，最后可以看作是一个优化问题。而接下来我们将从贝叶斯学派的观点来看待，即参数是未知的变量，它自身也是遵循某个概率分布的，我们只有它的先验分布，需要根据观察到的数据来进行调整。</p> <p>和上面保持一致，对于给定数据x，其对应的ground-truth \(y^*\) 可以表示为</p> \[y^* = x^T\beta + \epsilon\] <p>在这里，噪声 \(\epsilon \sim N(0,\sigma^2)\) 。和上面相同，我们有 \(y^* \sim N(x^T\beta,\sigma^2)\) 。唯一不同的是，在贝叶斯中我们认为模型 \(\beta\) 自身也是有一个概率分布的，我们只知道其先验分布为 \(\beta \sim N(0,\Sigma)\)</p> <p>根据贝叶斯法则，我们写出模型参数的后验分布 \(P(\beta\vert Y,X)\)</p> \[P(\beta\vert Y,X) = \frac{P(X,Y,\beta)}{P(X,Y)} = \frac{P(X\vert\beta)}{P(X,Y)}P(Y\vert X,\beta)P(\beta)\] <p>可以看出，后验正比于先验与似然之积，且似然与先验都是高斯分布，所以后验也是高斯分布。我们首先假设 \(\beta\vert Y,X \sim N(\mu',\Sigma')\) ，在下面的部分我们将求出后验分布的具体均值及方差。</p> <p>因为我们已经确定后验服从高斯分布，所以我们只考虑 \(P(Y\vert X,\beta)P(\beta)\) 的指数部分就可以确定未知量。</p> \[P(Y\vert X,\beta)P(\beta) = Cexp(-\frac{1}{2\sigma^2}(Y-X\beta)^T(Y-X\beta))exp(-\frac{1}{2}\beta^T\Sigma^{-1}\beta)\] <p>化简可得</p> \[P(Y\vert X,\beta)P(\beta) = Cexp(-\frac{1}{2}\beta^T(\sigma^{-2}X^TX+\Sigma^{-1})\beta + \sigma^{-2}Y^TX\beta -\frac{1}{2}\sigma^{-2}Y^TY)\] <p>而我们将假设的 \(\beta\vert Y,X \sim N(\mu',\Sigma')\) 展开写出来可得到</p> \[P(\beta\vert Y,X) = C'exp(-\frac{1}{2}\beta^T(\Sigma^{'-1})\beta + \mu^{'T}\Sigma^{'-1}\beta -\frac{1}{2}\mu^{'T}\Sigma^{'-1}\mu'\] <p>我们已经知道了正比关系 \(P(\beta\vert Y,X) \propto P(Y\vert X,\beta)P(\beta)\) ，所以将上面两个形式对比可得到</p> \[\Sigma^{'-1} = \sigma^{-2}X^TX+\Sigma^{-1}\] <p>为对称矩阵，\((\Sigma^{'-1})^T=\Sigma^{'-1}\)，我们进一步求均值 \(\mu'\)</p> \[\Sigma^{'-1}\mu' = (\mu^{'T}(\Sigma^{'-1})^T)^T = (\sigma^{-2}Y^TX)^T = \sigma^{-2}X^TY\] \[\mu' = \sigma^{-2}\Sigma'X^TY\] <p>至此，我们得到了后验分布 \(\beta\vert Y,X \sim N(\mu',\Sigma')\) 的参数，接着就能够根据给定的数据 x 进行预测了。因为模型 \(\beta\) 不再是存在一个固定的最优值，而是服从一个分布，因此 \(y_{pred}\) 也可以看作是一个随机变量的函数，进而得到其均值和方差</p> \[y_{pred} = x^T\beta \Rightarrow y_{pred} \sim N(x^T\mu',x^T\Sigma'x)\] </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2023 Aofan Jiang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Last updated: November 29, 2023. </div> <div id="map-container" style="display: none;"> <script type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?cl=ffffff&amp;w=300&amp;t=n&amp;d=vcetvMKxQeU0A74GGVddvtKdDYpzY562Hjs3OBdOjBw"></script> </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>